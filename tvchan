#!/usr/bin/perl
use strict;
use warnings;
use POSIX ":sys_wait_h";
use Time::HiRes qw(sleep time);
use IO::Select;

# tvchan
# Copyright 2014,2015,2021 Elliot Wolk
# Licensed under the GNU General Public License v3 or later

my @EXTS_VIDEO = qw(
  mkv mks mk3d
  avi
  webm
  flv
  ogv
  drc
  mov qt
  wmv
  mp4 m4p m4v
  mpg mpeg mpe mpv m2v m2s m1s
  svi
  3gp 3g2
  divx
  vob
  m2ts
);
my @EXTS_MUSIC = qw(mp3 flac ogg m4a wma wav);

my $MAX_OSD_MSG_LEN = 60;
my $DEFAULT_WINDOW_TITLE = "tvchan-mpv";
my $DEFAULT_AUTO_SKIP_DELAY = 30;

my $MPV_PROPERTIES = {
  "force-window" => "true",
  "osd-scale" => "1.5",
  "osd-scale-by-window" => "false",
  "osd-bar" => "true",
  "osd-level" => "1",
  "osd-msg1" => "\"\"",
};

my %TVCHAN_COMMAND_KEYS = (
  back     => [qw( F9  1       )],
  forward  => [qw( F10 2 ENTER )],
  end      => [qw( F11 3       )],
  quit     => [qw( F12 4 q     )],
  autoskip => [qw( F5  5       )],
  quitall  => [qw( DEL         )],
);

sub loadFile($$$$$$$);
sub getRandomEntry($$);
sub getRandomPos($);
sub writeInputConf($$);
sub socatJson($$);
sub setProperty($$$);
sub isPlaying($);
sub getProcLines(@);
sub getProcLinesNoFail(@);
sub canRead($);

my $usage = "Usage:
  $0 [OPTS] DIR [DIR ..]

  OPTS:
  -b | --beginning | --start
    always start at the beginning of the file

  -u | --uniq | --unique
    show each file at most only once

  -m | --music
    include (@EXTS_MUSIC) instead of just (@EXTS_VIDEO)

  -s STRING | --search STRING | --imdb STRING
    use 'imdb' crawling+caching script to filter files

  -a [SECONDS] | --autoskip [SECONDS] | --autoskip=SECONDS
     start in autoskip mode, and optionally set the delay to SECONDS
       {default is $DEFAULT_AUTO_SKIP_DELAY}
     SECONDS (optional) is the number of seconds to wait before running forward
     autoskip timer is reset when a new video is opened
     autoskip is suspended/resumed when 'auto' key command is run

  -fs | --fs | --fullscreen
    fullscreen: pass '--fs' to mpv (this is the default)

  -nofs | --nofs | -no-fs | --no-fs | --nofullscreen
    no fullscreen: pass '--no-fs' to mpv

  -g GEOMETRY | -geometry GEOMETRY | --geometry GEOMETRY | --geometry=GEOMETRY
     set geometry to mpv with '--geometry=GEOMETRY'
     e.g: '-geometry 1920x1080'

  -t TITLE | -title TITLE | --title TITLE | --geometry=TITLE
    set the mpv window title with '--title=TITLE'
    default is $DEFAULT_WINDOW_TITLE
";

sub main(@){
  my $autoSkip = 0;
  my $music = 0;
  my $begin = 0;
  my $unique = 0;
  my $fullscreen = 1;
  my $geometry = undef;
  my $windowTitle = $DEFAULT_WINDOW_TITLE;
  my $autoSkipDelay = $DEFAULT_AUTO_SKIP_DELAY;
  my $search;
  my $dirs = [];
  while(@_ > 0){
    my $arg = shift;
    if($arg =~ /^(-b|--beginning|--start)$/){
      $begin = 1;
    }elsif($arg =~ /^(-u|--uniq|--unique)$/ and @_ > 0){
      $unique = 1;
    }elsif($arg =~ /^(-m|--music)$/){
      $music = 1;
    }elsif($arg =~ /^(-s|--search|--imdb)$/ and @_ > 0){
      $search = shift;
    }elsif($arg =~ /^--autoskip=(\d+)$/){
      $autoSkip = 1;
      $autoSkipDelay = $1;
    }elsif($arg =~ /^(-a|--autoskip)$/ and @_ > 0 and $_[0] =~ /^\d+$/){
      $autoSkip = 1;
      $autoSkipDelay = shift;
    }elsif($arg =~ /^(-a|--autoskip)$/){
      $autoSkip = 1;
    }elsif($arg =~ /^(-fs|--fs|--fullscreen)$/){
      $fullscreen = 1;
    }elsif($arg =~ /^(-nofs|--nofs|-no-fs|--no-fs|--nofullscreen)$/){
      $fullscreen = 0;
    }elsif($arg =~ /^--geometry=(.+)$/){
      $geometry = $1;
    }elsif($arg =~ /^(-g|-geometry|--geometry)$/ and @_ > 0){
      $geometry = shift;
    }elsif($arg =~ /^--title=(.+)$/){
      $windowTitle = $1;
    }elsif($arg =~ /^(-t|-title|--title)$/ and @_ > 0){
      $windowTitle = shift;
    }elsif(-d $arg){
      push @$dirs, $arg;
    }else{
      die "$usage\nERROR: unknown arg $arg\n";;
    }
  }
  die "$usage\nERROR: must give at least one DIR\n" if @$dirs == 0;

  my $nowMillis = int(time*1000);
  my $ipcServerFifo = "/tmp/mpv-tvchan-commands-$nowMillis";
  my $inputConfFile = "/tmp/mpv-tvchan-input-$nowMillis.conf";

  my $inputConf = {};
  for my $tvchanCmd(sort keys %TVCHAN_COMMAND_KEYS){
    my @keynames = @{$TVCHAN_COMMAND_KEYS{$tvchanCmd}};
    $$inputConf{$_} = "print-text tvchan-cmd:$tvchanCmd" foreach @keynames;
  }

  writeInputConf($inputConfFile, $inputConf);

  my @exts = $music ? (@EXTS_VIDEO, @EXTS_MUSIC) : (@EXTS_VIDEO);

  my @cmd;
  push @cmd, "find";
  push @cmd, "-L";
  for my $dir(@$dirs){
    die "\"$dir\" is not a directory\n" if not -d $dir;
    push @cmd, $dir;
  }
  @cmd = (@cmd, "-type", "f");
  push @cmd, "-false";
  for my $ext(@exts){
    push @cmd, ("-or", "-iname", "*.$ext");
  }

  my $files = getProcLines @cmd;
  chomp foreach @$files;

  if(defined $search){
    my $newFiles = [];
    for my $file(@$files){
      my $imdb = join '', @{getProcLinesNoFail("imdb", "-c", $file)};
      if($imdb =~ /$search/i){
        push @$newFiles, $file;
      }
    }
    $files = $newFiles;
    print "SELECTED:\n" . join "\n", @$files;
  }

  my $index = 0;
  my $history = [];

  my $start;

  system "rm", "-f", $ipcServerFifo;

  my @mpvCmd = ("mpv");
  push @mpvCmd, "--idle";
  push @mpvCmd, "--quiet";
  push @mpvCmd, "--input-conf=$inputConfFile";
  push @mpvCmd, "--input-ipc-server=$ipcServerFifo";
  push @mpvCmd, "--title=$windowTitle";
  push @mpvCmd, ($fullscreen ? "--fs" : "--no-fs");
  push @mpvCmd, "--geometry=$geometry" if defined $geometry;

  open my $mpvCmdFH, "-|", @mpvCmd;
  my $ioSelect = IO::Select->new($mpvCmdFH);

  sleep 0.5;
  if(not -e $ipcServerFifo){
    die "ERROR: ipc server fifo does not exist \"$ipcServerFifo\"\n";
  }else{
    print "IPC server fifo: $ipcServerFifo\n";
  }

  for my $propertyName(sort keys %$MPV_PROPERTIES){
    my $val = $$MPV_PROPERTIES{$propertyName};
    print "$propertyName\n";
    setProperty($ipcServerFifo, $propertyName, $val);
    print "\n";
  }

  loadFile($ipcServerFifo, $files, $history, $dirs, $index, $unique, $begin);
  $start = time;

  while(1){
    my $line;
    if(canRead($ioSelect)){
      $line = <$mpvCmdFH>;
      if(defined $line){
        print $line;
      }
    }

    my $cmd = undef;
    $cmd = $1 if defined $line and $line =~ /tvchan-cmd:(\w+)/;

    if(not defined $cmd and $autoSkip && time - $start > $autoSkipDelay){
      print "\nauto-skipped\n";
      $cmd = "forward";
    }

    if(not defined $cmd and not isPlaying($ipcServerFifo)){
      $cmd = "forward";
    }

    if(not defined $line){
      sleep 0.3;
    }

    $cmd = "" if not defined $cmd;
    if($cmd eq "back"){
      $index--;
      $index = 0 if $index < 0;
      loadFile($ipcServerFifo, $files, $history, $dirs, $index, $unique, $begin);
      $start = time;
    }elsif($cmd eq "forward"){
      $index++;
      $index = @$history if $index > @$history;
      loadFile($ipcServerFifo, $files, $history, $dirs, $index, $unique, $begin);
      $start = time;
    }elsif($cmd eq "end"){
      $index = @$history;
      loadFile($ipcServerFifo, $files, $history, $dirs, $index, $unique, $begin);
      $start = time;
    }elsif($cmd eq "quit"){
      socatJson($ipcServerFifo, "quit");
      exit 0;
    }elsif($cmd eq "autoskip"){
      $autoSkip = not $autoSkip;
    }elsif($cmd eq "quitall"){
      system "pkill -9 mpv >/dev/null 2>/dev/null";
      system "nohup pkill -9 tvchan >/dev/null 2>/dev/null &";
      exit 1;
    }

  }
  close $mpvCmdFH;
}

sub loadFile($$$$$$$){
  my ($ipcServerFifo, $files, $history, $dirs, $index, $unique, $begin) = @_;

  my ($file, $pos);
  if($index < @$history){
    ($file, $pos) = @{$$history[$index]};
  }else{
    die "no files found\n" if @$files == 0;
    my $deleteEntry = $unique;
    $file = getRandomEntry $files, $deleteEntry;

    if($begin){
      $pos = 0;
    }else{
      $pos = getRandomPos $file;
    }
    push @$history, [$file, $pos];
  }

  my $msg = $file;
  for my $dir(@$dirs){
    $msg =~ s/^$dir//;
  }
  my $len = length $msg;
  if($len > $MAX_OSD_MSG_LEN){
    $msg = substr $msg, $len - $MAX_OSD_MSG_LEN;
  }

  print "\n\nPLAYING: $file @ $pos\n\n";
  socatJson($ipcServerFifo, "loadfile \"$file\" replace \"start=$pos\"");
  socatJson($ipcServerFifo, "show-text \"$msg\" 1500");
  socatJson($ipcServerFifo, "show-progress");
}

sub getRandomEntry($$){
  my ($arr, $deleteEntry) = @_;
  my $randIndex = rand @$arr;
  my $entry = $$arr[$randIndex];
  splice @$arr, $randIndex, 1 if $deleteEntry;
  return $entry;
}

sub getRandomPos($){
  my $file = shift;
  die "Could not find \"$file\"\n" if not -f $file;
  my $durLines = getProcLines "duration", "-n", "-s", $file;
  my $dur;
  if(@$durLines == 1 and $$durLines[0] =~ /^(\d+|\d*\.\d+)$/){
    $dur = $1;
  }
  if(not defined $dur){
    print STDERR "ERROR: failed to obtain duration if $file\n";
    return 0;
  }

  my $pos = rand() * $dur;
  return sprintf '%.2f', $pos;
}

sub writeInputConf($$){
  my ($inputConfFile, $inputConf) = @_;
  my $conf = '';
  for my $key(keys %$inputConf){
    $conf .= "$key $$inputConf{$key}\n";
  }
  open FH, "> $inputConfFile" or die "Could not write to $inputConfFile\n";
  print FH $conf;
  close FH;
}

sub socatJson($$){
  my ($ipcServerFifo, $json) = @_;
  return undef if not -e $ipcServerFifo;
  $json =~ s/'/'\\''/g;
  my $out = `echo '$json' | socat - $ipcServerFifo 2>/dev/null`;
  chomp $out;
  return $out;
}

sub setProperty($$$){
  my ($ipcServerFifo, $property, $value) = @_;
  my $json = "{ \"command\": [\"set_property\", \"$property\", $value] }";
  my $out = socatJson $ipcServerFifo, $json;
  print $out;
}

sub isPlaying($){
  my ($ipcServerFifo, $property, $value) = @_;
  my $json = '{ "command": ["get_property", "filename"] }';
  my $out = socatJson $ipcServerFifo, $json;

  return 0 if not defined $out;

  if($out =~ /"error":"success"/){
    return 1;
  }elsif($out =~ /"error":"property unavailable"/){
    return 0;
  }
  print "$out\n";

  return 0;
}

sub getProcLines(@){
  my $lines = getProcLinesNoFail @_;
  die "Error running \"@_\"\n" if $? != 0;
  return $lines;
}
sub getProcLinesNoFail(@){
  open FH, "-|", @_;
  my @lines = <FH>;
  close FH;
  return \@lines;
}

sub canRead($){
  my ($ioSelect) = @_;
  my @ready = $ioSelect->can_read(0);
  return @ready == 1;
}

&main(@ARGV);
